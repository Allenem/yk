#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>
using std::vector;
using std::function;
using std::cout;
using std::endl;

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<int> initialSet(n);
        for(int v:initial) initialSet[v] = 1;

        function<void(vector<int>&, int)> dfs = [&](vector<int>& infectedSet, int v) {
            for(int u=0; u<n; u++){
                if(!graph[v][u] || initialSet[u] || infectedSet[u]) continue;
                infectedSet[u] = 1;
                dfs(infectedSet, u);
            }
        };

        // traverse initial, get every u's infect source list infectedRootOf [v1, v2, ...]
        vector<vector<int>> infectedRootOf(n);
        for(int v:initial){
            vector<int> infectedSet(n); // new one and update during each new v
            dfs(infectedSet, v);
            for(int u=0; u<n; u++){
                if(infectedSet[u] == 1) infectedRootOf[u].push_back(v);
            }
        }

        // traverse n nodes, get only root v of nood u, let cnt[v]++
        vector<int> cnt(n);
        for (int u=0; u<n; u++){
            if (infectedRootOf[u].size() == 1) cnt[infectedRootOf[u][0]]++;
        }

        // get the cnt be maxium, which means the health number will be smallest; 
        // or cnts are same, but index should be smaller
        int ans = initial[0];
        for(int v:initial){
            // && has a higher priority than ||
            if(cnt[v] > cnt[ans] || cnt[v] == cnt[ans] && v < ans) ans = v;
        }

        return ans;
    }
};

int main(){
    Solution s;
    vector<vector<int>> graph = {{1,1,0},{1,1,0},{0,0,1}};
    vector<int> initial = {0,1};
    cout << s.minMalwareSpread(graph, initial) << endl;

    graph = {{1,1,0},{1,1,1},{0,1,1}};
    initial = {0,1};
    cout << s.minMalwareSpread(graph, initial) << endl;

    graph = {{1,1,0,0},{1,1,1,0},{0,1,1,1},{0,0,1,1}};
    initial = {0,1};
    cout << s.minMalwareSpread(graph, initial) << endl;

    return 0;
}